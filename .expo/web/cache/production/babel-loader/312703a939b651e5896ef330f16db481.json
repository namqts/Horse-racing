{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;})),keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach(function(key){_defineProperty(target,key,source[key]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}return target;}import{clamp,focusWithoutScrolling,mergeProps,useGlobalListeners}from'@react-aria/utils';import{getSliderThumbId,sliderIds}from\"./utils\";import{useCallback,useEffect,useRef}from'react';import{useFocusable}from'@react-aria/focus';import{useLabel}from'@react-aria/label';import{useMove}from\"./useMove\";import{isRTL}from'@react-native-aria/utils';export function useSliderThumb(opts,state){var _opts$ariaLabelledby;var index=opts.index,isRequired=opts.isRequired,isDisabled=opts.isDisabled,validationState=opts.validationState,trackLayout=opts.trackLayout,inputRef=opts.inputRef;var isVertical=opts.orientation==='vertical';var direction=isRTL()?'rtl':undefined;var _useGlobalListeners=useGlobalListeners(),addGlobalListener=_useGlobalListeners.addGlobalListener,removeGlobalListener=_useGlobalListeners.removeGlobalListener;var labelId=sliderIds.get(state);var _useLabel=useLabel(_objectSpread(_objectSpread({},opts),{},{'id':getSliderThumbId(state,index),'aria-labelledby':(labelId+\" \"+((_opts$ariaLabelledby=opts['aria-labelledby'])!==null&&_opts$ariaLabelledby!==void 0?_opts$ariaLabelledby:'')).trim()})),labelProps=_useLabel.labelProps,fieldProps=_useLabel.fieldProps;var value=state.values[index];var focusInput=useCallback(function(){if(inputRef.current){focusWithoutScrolling(inputRef.current);}},[inputRef]);var isFocused=state.focusedThumb===index;useEffect(function(){if(isFocused){focusInput();}},[isFocused,focusInput]);var stateRef=useRef(null);stateRef.current=state;var reverseX=direction==='rtl';var currentPosition=useRef(null);var _useMove=useMove({onMoveStart:function onMoveStart(){currentPosition.current=null;state.setThumbDragging(index,true);},onMove:function onMove(_ref){var deltaX=_ref.deltaX,deltaY=_ref.deltaY,pointerType=_ref.pointerType;var size=isVertical?trackLayout.height:trackLayout.width;if(currentPosition.current==null){currentPosition.current=stateRef.current.getThumbPercent(index)*size;}if(pointerType==='keyboard'){var delta=((reverseX?-deltaX:deltaX)+(isVertical?-deltaY:-deltaY))*stateRef.current.step;currentPosition.current+=delta*size;stateRef.current.setThumbValue(index,stateRef.current.getThumbValue(index)+delta);}else{var _delta=isVertical?deltaY:deltaX;if(isVertical||reverseX){_delta=-_delta;}currentPosition.current+=_delta;stateRef.current.setThumbPercent(index,clamp(currentPosition.current/size,0,1));}},onMoveEnd:function onMoveEnd(){state.setThumbDragging(index,false);}}),moveProps=_useMove.moveProps;state.setThumbEditable(index,!isDisabled);var _useFocusable=useFocusable(mergeProps(opts,{onFocus:function onFocus(){return state.setFocusedThumb(index);},onBlur:function onBlur(){return state.setFocusedThumb(undefined);}}),inputRef),focusableProps=_useFocusable.focusableProps;var currentPointer=useRef(undefined);var onDown=function onDown(id){focusInput();currentPointer.current=id;state.setThumbDragging(index,true);addGlobalListener(window,'mouseup',onUp,false);addGlobalListener(window,'touchend',onUp,false);addGlobalListener(window,'pointerup',onUp,false);};var onUp=function onUp(e){var _e$pointerId,_e$changedTouches;var id=(_e$pointerId=e.pointerId)!==null&&_e$pointerId!==void 0?_e$pointerId:(_e$changedTouches=e.changedTouches)===null||_e$changedTouches===void 0?void 0:_e$changedTouches[0].identifier;if(id===currentPointer.current){focusInput();state.setThumbDragging(index,false);removeGlobalListener(window,'mouseup',onUp,false);removeGlobalListener(window,'touchend',onUp,false);removeGlobalListener(window,'pointerup',onUp,false);}};return{inputProps:mergeProps(focusableProps,fieldProps,{'type':'range','tabIndex':!isDisabled?0:undefined,'min':state.getThumbMinValue(index),'max':state.getThumbMaxValue(index),'step':state.step,'value':value,'disabled':isDisabled,'aria-orientation':opts.orientation,'aria-valuetext':state.getThumbValueLabel(index),'aria-required':isRequired||undefined,'aria-invalid':validationState==='invalid'||undefined,'aria-errormessage':opts['aria-errormessage'],'onChange':function onChange(e){state.setThumbValue(index,parseFloat(e.target.value));}}),thumbProps:!isDisabled?mergeProps(moveProps,{onMouseDown:function onMouseDown(e){if(e.button!==0||e.altKey||e.ctrlKey||e.metaKey){return;}onDown();},onPointerDown:function onPointerDown(e){if(e.button!==0||e.altKey||e.ctrlKey||e.metaKey){return;}onDown(e.pointerId);},onTouchStart:function onTouchStart(e){onDown(e.changedTouches[0].identifier);}}):{},labelProps:labelProps};}","map":{"version":3,"sources":["useSliderThumb.web.ts"],"names":["clamp","focusWithoutScrolling","mergeProps","useGlobalListeners","getSliderThumbId","sliderIds","useCallback","useEffect","useRef","useFocusable","useLabel","useMove","isRTL","useSliderThumb","opts","state","index","isRequired","isDisabled","validationState","trackLayout","inputRef","isVertical","orientation","direction","undefined","addGlobalListener","removeGlobalListener","labelId","get","labelProps","fieldProps","trim","value","values","focusInput","current","isFocused","focusedThumb","stateRef","reverseX","currentPosition","moveProps","onMoveStart","setThumbDragging","onMove","deltaX","deltaY","pointerType","size","height","width","getThumbPercent","delta","step","setThumbValue","getThumbValue","setThumbPercent","onMoveEnd","setThumbEditable","focusableProps","onFocus","setFocusedThumb","onBlur","currentPointer","onDown","id","window","onUp","e","pointerId","changedTouches","identifier","inputProps","getThumbMinValue","getThumbMaxValue","getThumbValueLabel","parseFloat","target","thumbProps","onMouseDown","button","altKey","ctrlKey","metaKey","onPointerDown","onTouchStart"],"mappings":"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","sourcesContent":["import { AriaSliderThumbProps } from '@react-types/slider';\nimport {\n  clamp,\n  focusWithoutScrolling,\n  mergeProps,\n  useGlobalListeners,\n} from '@react-aria/utils';\nimport { getSliderThumbId, sliderIds } from './utils';\nimport React, {\n  ChangeEvent,\n  HTMLAttributes,\n  InputHTMLAttributes,\n  LabelHTMLAttributes,\n  RefObject,\n  useCallback,\n  useEffect,\n  useRef,\n} from 'react';\nimport { SliderState } from '@react-stately/slider';\nimport { useFocusable } from '@react-aria/focus';\nimport { useLabel } from '@react-aria/label';\nimport { useMove } from './useMove';\nimport { isRTL } from '@react-native-aria/utils';\n\ninterface SliderThumbAria {\n  /** Props for the root thumb element; handles the dragging motion. */\n  thumbProps: HTMLAttributes<HTMLElement>;\n\n  /** Props for the visually hidden range input element. */\n  inputProps: InputHTMLAttributes<HTMLInputElement>;\n\n  /** Props for the label element for this thumb (optional). */\n  labelProps: LabelHTMLAttributes<HTMLLabelElement>;\n}\n\ninterface SliderThumbOptions extends AriaSliderThumbProps {\n  /** A ref to the track element. */\n  trackLayout: any;\n  /** A ref to the thumb input element. */\n  inputRef: RefObject<HTMLInputElement>;\n}\n\n/**\n * Provides behavior and accessibility for a thumb of a slider component.\n *\n * @param opts Options for this Slider thumb.\n * @param state Slider state, created via `useSliderState`.\n */\nexport function useSliderThumb(\n  opts: SliderThumbOptions,\n  state: SliderState\n): SliderThumbAria {\n  let {\n    index,\n    isRequired,\n    isDisabled,\n    validationState,\n    trackLayout,\n    inputRef,\n  } = opts;\n\n  let isVertical = opts.orientation === 'vertical';\n\n  let direction = isRTL() ? 'rtl' : undefined;\n  let { addGlobalListener, removeGlobalListener } = useGlobalListeners();\n\n  let labelId = sliderIds.get(state);\n  const { labelProps, fieldProps } = useLabel({\n    ...opts,\n    'id': getSliderThumbId(state, index),\n    'aria-labelledby': `${labelId} ${opts['aria-labelledby'] ?? ''}`.trim(),\n  });\n\n  const value = state.values[index];\n\n  const focusInput = useCallback(() => {\n    if (inputRef.current) {\n      focusWithoutScrolling(inputRef.current);\n    }\n  }, [inputRef]);\n\n  const isFocused = state.focusedThumb === index;\n\n  useEffect(() => {\n    if (isFocused) {\n      focusInput();\n    }\n  }, [isFocused, focusInput]);\n\n  const stateRef = useRef<SliderState>(null);\n  stateRef.current = state;\n  let reverseX = direction === 'rtl';\n  let currentPosition = useRef<number>(null);\n  let { moveProps } = useMove({\n    onMoveStart() {\n      currentPosition.current = null;\n      state.setThumbDragging(index, true);\n    },\n    onMove({ deltaX, deltaY, pointerType }) {\n      let size = isVertical ? trackLayout.height : trackLayout.width;\n\n      if (currentPosition.current == null) {\n        currentPosition.current =\n          stateRef.current.getThumbPercent(index) * size;\n      }\n      if (pointerType === 'keyboard') {\n        // (invert left/right according to language direction) + (according to vertical)\n        let delta =\n          ((reverseX ? -deltaX : deltaX) + (isVertical ? -deltaY : -deltaY)) *\n          stateRef.current.step;\n        currentPosition.current += delta * size;\n        stateRef.current.setThumbValue(\n          index,\n          stateRef.current.getThumbValue(index) + delta\n        );\n      } else {\n        let delta = isVertical ? deltaY : deltaX;\n        if (isVertical || reverseX) {\n          delta = -delta;\n        }\n        currentPosition.current += delta;\n        stateRef.current.setThumbPercent(\n          index,\n          clamp(currentPosition.current / size, 0, 1)\n        );\n      }\n    },\n    onMoveEnd() {\n      state.setThumbDragging(index, false);\n    },\n  });\n\n  // Immediately register editability with the state\n  state.setThumbEditable(index, !isDisabled);\n\n  const { focusableProps } = useFocusable(\n    mergeProps(opts, {\n      onFocus: () => state.setFocusedThumb(index),\n      onBlur: () => state.setFocusedThumb(undefined),\n    }),\n    inputRef\n  );\n\n  let currentPointer = useRef<number | undefined>(undefined);\n  let onDown = (id?: number) => {\n    focusInput();\n    currentPointer.current = id;\n    state.setThumbDragging(index, true);\n\n    addGlobalListener(window, 'mouseup', onUp, false);\n    addGlobalListener(window, 'touchend', onUp, false);\n    addGlobalListener(window, 'pointerup', onUp, false);\n  };\n\n  let onUp = (e) => {\n    let id = e.pointerId ?? e.changedTouches?.[0].identifier;\n    if (id === currentPointer.current) {\n      focusInput();\n      state.setThumbDragging(index, false);\n      removeGlobalListener(window, 'mouseup', onUp, false);\n      removeGlobalListener(window, 'touchend', onUp, false);\n      removeGlobalListener(window, 'pointerup', onUp, false);\n    }\n  };\n\n  // We install mouse handlers for the drag motion on the thumb div, but\n  // not the key handler for moving the thumb with the slider.  Instead,\n  // we focus the range input, and let the browser handle the keyboard\n  // interactions; we then listen to input's onChange to update state.\n  return {\n    inputProps: mergeProps(focusableProps, fieldProps, {\n      'type': 'range',\n      'tabIndex': !isDisabled ? 0 : undefined,\n      'min': state.getThumbMinValue(index),\n      'max': state.getThumbMaxValue(index),\n      'step': state.step,\n      'value': value,\n      'disabled': isDisabled,\n      'aria-orientation': opts.orientation,\n      'aria-valuetext': state.getThumbValueLabel(index),\n      'aria-required': isRequired || undefined,\n      'aria-invalid': validationState === 'invalid' || undefined,\n      'aria-errormessage': opts['aria-errormessage'],\n      'onChange': (e: ChangeEvent<HTMLInputElement>) => {\n        state.setThumbValue(index, parseFloat(e.target.value));\n      },\n    }),\n    thumbProps: !isDisabled\n      ? mergeProps(moveProps, {\n          onMouseDown: (e: React.MouseEvent<HTMLElement>) => {\n            if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n              return;\n            }\n            onDown();\n          },\n          onPointerDown: (e: React.PointerEvent<HTMLElement>) => {\n            if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n              return;\n            }\n            onDown(e.pointerId);\n          },\n          onTouchStart: (e: React.TouchEvent<HTMLElement>) => {\n            onDown(e.changedTouches[0].identifier);\n          },\n        })\n      : {},\n    labelProps,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}